<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mouse AHK - v5.8</title>
<style>
    :root { 
        --primary: #3793ff; --bg: #121212; --card: #1e1e1e; 
        --text: #e0e0e0; --border: #333; --input-bg: #2d2d2d; 
    }
    body { font-family: 'Segoe UI', system-ui, sans-serif; margin: 24px; background: var(--bg); color: var(--text); line-height: 1.5; padding-bottom: 120px; }
    .context { background: var(--card); border-radius: 12px; padding: 20px; margin-bottom: 24px; box-shadow: 0 8px 16px rgba(0,0,0,0.4); border: 1px solid var(--border); }
    .header { display: flex; gap: 12px; align-items: center; margin-bottom: 16px; border-bottom: 1px solid var(--border); padding-bottom: 12px; }
    .tag-container { display: flex; gap: 8px; flex-wrap: wrap; }
    .tag { background: #1a3a5a; color: var(--primary); padding: 4px 12px; border-radius: 16px; font-size: 0.85rem; display: flex; align-items: center; gap: 8px; border: 1px solid var(--primary); }
    table { width: 100%; border-collapse: collapse; }
    th { text-align: left; font-size: 0.75rem; color: #888; padding: 8px; }
    td { padding: 8px; vertical-align: top; border-bottom: 1px solid var(--border); }
    button { padding: 5px 12px; border-radius: 6px; border: 1px solid var(--border); background: #333; color: white; cursor: pointer; transition: 0.1s; }
    button:hover { background: #444; }
    .btn-main { background: var(--primary); color: white; border: none; font-weight: 600; padding: 8px 16px; }
    .btn-add { color: var(--primary); border-color: var(--primary); background: transparent; margin-top: 5px; font-size: 0.75rem; }
    select, input { padding: 6px; border-radius: 6px; border: 1px solid var(--border); background: var(--input-bg); color: white; }
    .rec-input { width: 90px; font-weight: bold; color: #ff5252; text-align: center; }
    .mod-pill { margin: 2px; font-size: 0.8rem; border: 1px solid #444; opacity: 0.6; }
    .mod-pill.active { opacity: 1; border-color: var(--primary); background: #1a3a5a; color: var(--primary); font-weight: bold; }
    .builder-container { background: #161616; padding: 8px; border-radius: 8px; margin-top: 5px; border-left: 3px solid var(--primary); }
    .builder-step { display: flex; align-items: center; gap: 6px; margin-bottom: 4px; }
    .gesture-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; background: #181818; padding: 12px; border-radius: 8px; border: 1px solid var(--border); }
    .toolbar { position: fixed; bottom: 24px; left: 50%; transform: translateX(-50%); background: #252525; padding: 12px 24px; border-radius: 50px; display: flex; gap: 16px; box-shadow: 0 8px 32px rgba(0,0,0,0.5); z-index: 100; border: 1px solid #444; }
</style>
</head>
<body>

<h1>Mouse AHK Configurator <small style="font-size: 0.5em; color: #666;">v5.8 </small></h1>

<div id="contexts-container"></div>

<div class="toolbar">
    <button class="btn-main" onclick="addContext(false)">+ App Context</button>
    <button onclick="addContext(true)">üåç Global Context</button>
    <button class="btn-main" style="background:#2e7d32" onclick="exportAHK()">üíæ Export .ahk</button>
    <button onclick="document.getElementById('fileInput').click()">üìÇ Load .ahk</button>
    <input type="file" id="fileInput" hidden accept=".ahk" onchange="handleImport(this)">
</div>

<script>
const CONFIG = {
    inputs: ["Back", "Forward", "Middle", "WheelUp", "WheelDown", "WheelLeft", "WheelRight", "Back+Forward", "Custom"],
    modifiers: ["Ctrl", "Alt", "Shift", "Win", "Middle Held"],
    actions: ["None", "Shortcut", "Macro", "Copy", "Paste", "Cut", "Undo", "Redo", "VolUp", "VolDown", "Mute"],
    ahkMap: { "Copy": "^c", "Paste": "^v", "Cut": "^x", "Undo": "^z", "Redo": "^y", "VolUp": "{Volume_Up}", "VolDown": "{Volume_Down}", "Mute": "{Volume_Mute}" },
    mouseMap: { "Back": "XButton1", "Forward": "XButton2", "Middle": "MButton", "Back+Forward": "XButton1 & XButton2" },
    modSymbols: { "Ctrl": "^", "Alt": "!", "Shift": "+", "Win": "#" },
    keyMap: { "ArrowLeft": "Left", "ArrowRight": "Right", "ArrowUp": "Up", "ArrowDown": "Down", "Control": "Ctrl", "Meta": "Win", "Escape": "Esc", " ": "Space" }
};

const container = document.getElementById('contexts-container');

function createRecorder(val = "") {
    const wrap = document.createElement('div'); wrap.className = 'rec-box';
    const i = document.createElement('input'); i.className = 'rec-input'; i.value = val;
    i.oninput = save;
    const btnRec = document.createElement('button'); btnRec.textContent = "‚è∫";
    btnRec.onclick = () => {
        i.value = "...";
        const handler = (e) => {
            e.preventDefault();
            let k = CONFIG.keyMap[e.key] || e.key;
            i.value = k; window.removeEventListener('keydown', handler); save();
        };
        window.addEventListener('keydown', handler);
    };
    wrap.append(i, btnRec); return { wrap, input: i };
}

function createModifierUI(savedMods = []) {
    const wrap = document.createElement('div');
    CONFIG.modifiers.forEach(m => {
        const btnMod = document.createElement('button');
        btnMod.className = "mod-pill" + (savedMods.includes(m) ? " active" : "");
        btnMod.textContent = m;
        btnMod.onclick = () => { btnMod.classList.toggle('active'); save(); };
        wrap.appendChild(btnMod);
    });
    return wrap;
}

function createActionInterface(data = null) {
    const mainWrap = document.createElement('div');
    const typeSel = createSelect(CONFIG.actions, data?.type || "None");
    const uiBox = document.createElement('div');
    const renderUI = () => {
        uiBox.innerHTML = "";
        if (typeSel.value === "Shortcut" || typeSel.value === "Macro") {
            const bWrap = document.createElement('div'); bWrap.className = 'builder-container';
            const sList = document.createElement('div');
            const addS = (sd = null) => {
                const step = document.createElement('div'); step.className = 'builder-step';
                const rec = createRecorder(sd?.key || ""); step.append(rec.wrap);
                if (typeSel.value === "Macro") {
                    const d = document.createElement('input'); d.type="number"; d.style.width="55px";
                    d.value = sd?.delay || "50"; d.oninput = save;
                    step.append(document.createTextNode("wait"), d, document.createTextNode("ms"));
                }
                const rem = document.createElement('button'); rem.textContent = "√ó";
                rem.onclick = () => { step.remove(); save(); };
                step.append(rem); sList.appendChild(step);
            };
            const bAdd = document.createElement('button'); bAdd.className="btn-add";
            bAdd.textContent = typeSel.value === "Shortcut" ? "+ Key" : "+ Step";
            bAdd.onclick = () => { addS(); save(); };
            bWrap.append(sList, bAdd); uiBox.appendChild(bWrap);
            if(data?.steps) data.steps.forEach(s => addS(s)); else addS();
        }
    };
    typeSel.onchange = () => { renderUI(); save(); };
    mainWrap.append(typeSel, uiBox); renderUI(); return mainWrap;
}

function addContext(isGlobal, data = null) {
    const ctx = document.createElement('div'); ctx.className = 'context'; ctx.dataset.global = isGlobal;
    const header = document.createElement('div'); header.className = 'header';
    const tBox = document.createElement('div'); tBox.className = 'tag-container';
    if(!isGlobal) {
        header.appendChild(btn("+ Add App", () => {
            const n = prompt("Process (e.g. chrome.exe):"); if(n) renderTag(n, tBox);
        }));
    } else tBox.innerHTML = `<span class="tag global">GLOBAL FALLBACK</span>`;
    const dBtn = btn("Delete Context", () => { if(confirm("Delete?")) {ctx.remove(); save();} });
    dBtn.style.marginLeft="auto"; header.append(tBox, dBtn);
    const tbl = document.createElement('table');
    tbl.innerHTML = `<thead><tr><th style="width:20%">Trigger</th><th style="width:25%">Modifiers</th><th style="width:5%">Gest</th><th>Action</th><th style="width:5%"></th></tr></thead><tbody></tbody>`;
    ctx.append(header, tbl, btn("+ Add Row", () => addRow(tbl.querySelector('tbody'))));
    container.appendChild(ctx);
    if(data) { data.progs?.forEach(p => renderTag(p, tBox)); data.rows?.forEach(r => addRow(tbl.querySelector('tbody'), r)); }
}

function addRow(tbody, data = null) {
    const tr = document.createElement('tr');
    const recIn = createRecorder(data?.customIn || "");
    const selIn = createSelect(CONFIG.inputs, data?.input);
    recIn.wrap.style.display = data?.input === "Custom" ? "flex" : "none";
    selIn.onchange = () => { recIn.wrap.style.display = selIn.value === "Custom" ? "flex" : "none"; save(); };
    const modUI = createModifierUI(data?.mods || []);
    const selGest = createSelect(["No", "Yes"], data?.isGest);
    const mainAct = createActionInterface(data?.mainAction);
    const gGrid = document.createElement('div'); gGrid.className = 'gesture-grid';
    gGrid.style.display = data?.isGest === "Yes" ? 'grid' : 'none';
    ["Up", "Down", "Left", "Right"].forEach(d => {
        const w = document.createElement('div'); w.innerHTML = `<small><b>${d}</b></small>`;
        w.appendChild(createActionInterface(data?.gestures?.[d])); gGrid.appendChild(w);
    });
    selGest.onchange = () => {
        gGrid.style.display = selGest.value === "Yes" ? 'grid' : 'none';
        mainAct.style.display = selGest.value === "Yes" ? 'none' : 'block';
        save();
    };
    const tTd = document.createElement('td'); tTd.append(selIn, recIn.wrap);
    const aTd = document.createElement('td'); aTd.append(mainAct, gGrid);
    tr.append(tTd, td(modUI), td(selGest), aTd, td(btn("√ó", () => {tr.remove(); save();})));
    tbody.appendChild(tr);
}

function save() {
    const state = [...document.querySelectorAll('.context')].map(ctx => ({
        isGlobal: ctx.dataset.global === "true",
        progs: [...ctx.querySelectorAll('.tag span')].map(s => s.textContent),
        rows: [...ctx.querySelectorAll('tbody tr')].map(tr => ({
            input: tr.querySelector('td:nth-child(1) select').value,
            customIn: tr.querySelector('td:nth-child(1) .rec-input').value,
            mods: [...tr.querySelectorAll('.mod-pill.active')].map(b => b.textContent),
            isGest: tr.querySelector('td:nth-child(3) select').value,
            mainAction: getActionState(tr.querySelector('td:nth-child(4) > div:first-child')),
            gestures: Object.fromEntries(["Up","Down","Left","Right"].map((d, i) => [d, getActionState(tr.querySelectorAll('.gesture-grid > div')[i])]))
        }))
    }));
    localStorage.setItem('ahk_mouse_v5_8', JSON.stringify(state));
    return state;
}

function getActionState(el) {
    const type = el.querySelector('select').value;
    const steps = [...el.querySelectorAll('.builder-step')].map(s => ({
        key: s.querySelector('input.rec-input').value,
        delay: s.querySelector('input[type="number"]')?.value || "0"
    }));
    return { type, steps };
}

function exportAHK() {
    const state = save();

    let ahk = `#Requires AutoHotkey v2.0
#SingleInstance Force
CoordMode("Mouse","Screen")
A_MaxHotkeysPerInterval := 1000
gestureThreshold := 40

`;

    const tokenFor = (k) => {
        const low = (k || "").toLowerCase();
        if (low === "win") return "#";
        if (low === "ctrl") return "^";
        if (low === "alt") return "!";
        if (low === "shift") return "+";
        return k && k.length === 1 ? k : `{${k}}`;
    };

    const buildActionLines = (act) => {
        if (!act || act.type === "None") return "";
        if (act.type === "Shortcut") {
            let combo = "";
            let hasWin = false;
            act.steps.forEach(s => {
                const t = tokenFor(s.key);
                if (t === "#") hasWin = true;
                combo += t;
            });
            return `Send("${hasWin ? "{Blind}" : ""}${combo}")`;
        }
        if (act.type === "Macro") {
            return act.steps.map(s => `Send("{${s.key}}")\n  Sleep(${s.delay})`).join("\n  ");
        }
        if (act.type === "VolUp") return `Send("{Volume_Up}")`;
        if (act.type === "VolDown") return `Send("{Volume_Down}")`;
        if (act.type === "Mute") return `Send("{Volume_Mute}")`;
        if (act.type === "Copy") return `Send("^c")`;
        if (act.type === "Paste") return `Send("^v")`;
        if (act.type === "Cut") return `Send("^x")`;
        if (act.type === "Undo") return `Send("^z")`;
        if (act.type === "Redo") return `Send("^y")`;
        if (CONFIG.ahkMap[act.type]) return `Send("${CONFIG.ahkMap[act.type]}")`;
        return "";
    };

    const buildGestureBlockForRow = (hkKey, row) => {
        if (row.isGest === "No") {
            const actionLine = buildActionLines(row.mainAction);
            if (!actionLine) return `  ; no action defined\n`;
            return `  ${actionLine}\n`;
        }

        let block = `
  MouseGetPos(&sx, &sy)
  KeyWait("${hkKey}")
  MouseGetPos(&ex, &ey)
  dx := ex - sx, dy := ey - sy
  if (Abs(dx) < gestureThreshold && Abs(dy) < gestureThreshold) {
    ; small movement -> TAP - pass native click
    Send("{${hkKey}}")
    Return
  }
  dir := (Abs(dx) > Abs(dy)) ? (dx > 0 ? "Right" : "Left") : (dy > 0 ? "Down" : "Up")
`;
        ["Up", "Down", "Left", "Right"].forEach(d => {
            const act = row.gestures?.[d];
            const actLines = buildActionLines(act);
            if (actLines) {
                block += `  if (dir = "${d}") {\n    ${actLines}\n    Return\n  }\n`;
            }
        });
        return block;
    };

    state.forEach(ctx => {
        const scopeExpr = ctx.isGlobal ? "" : ctx.progs.map(p => `WinActive("ahk_exe ${p}")`).join(" || ");
        const mapByKey = {};

        // 1) build mapByKey keyed by "mods+raw"
        ctx.rows.forEach(r => {
            const raw = r.input === "Custom" ? r.customIn : (CONFIG.mouseMap[r.input] || r.input);
            const baseMods = (r.mods || []).filter(m => m !== "Middle Held").map(m => CONFIG.modSymbols[m]).join("");
            const keyName = baseMods + raw;
            if (!mapByKey[keyName]) mapByKey[keyName] = { keyName, raw, keyNameBaseMods: baseMods };
            if ((r.mods || []).includes("Middle Held")) mapByKey[keyName].mid = r;
            else mapByKey[keyName].base = r;
        });

        // 2) detect composite entries and attach composite info to component keys
        Object.keys(mapByKey).forEach(k => {
            const entry = mapByKey[k];
            if (entry.raw && entry.raw.includes("&")) {
                const cfgRow = entry.base || entry.mid;
                const actionLine = cfgRow ? buildActionLines(cfgRow.mainAction) : "";
                if (actionLine) {
                    // parse parts
                    const parts = entry.raw.split("&").map(s => s.trim());
                    if (parts.length === 2) {
                        const b1 = parts[0], b2 = parts[1];
                        // compute component keyNames using the same baseMods prefix
                        const baseMods = entry.keyNameBaseMods || "";
                        const b1Key = baseMods + b1;
                        const b2Key = baseMods + b2;
                        if (!mapByKey[b1Key]) mapByKey[b1Key] = { keyName: b1Key, raw: b1 };
                        if (!mapByKey[b2Key]) mapByKey[b2Key] = { keyName: b2Key, raw: b2 };
                        mapByKey[b1Key].composite = { other: b2, actionLine };
                        mapByKey[b2Key].composite = { other: b1, actionLine };
                    }
                }
                // remove the composite combined entry so it doesn't create its own handler
                delete mapByKey[k];
            }
        });

        // Emit scope header
        ahk += scopeExpr ? `#HotIf ${scopeExpr}\n` : "#HotIf\n";

        // 3) emit per-key handlers, now with composite checks integrated
        Object.values(mapByKey).forEach(entry => {
            const hk = entry.keyName;
            const needsTilde = (entry.raw === "XButton1" || entry.raw === "XButton2") ? "~" : "";

            // special-case MButton (do not check GetKeyState inside its own handler)
            if (entry.raw === "MButton") {
                ahk += `MButton:: {\n`;
                if (entry.base) {
                    const baseBlock = buildGestureBlockForRow(entry.raw, entry.base);
                    ahk += baseBlock.split("\n").map(l => l ? "  " + l : l).join("\n") + "\n";
                } else {
                    ahk += `  ; No mapping for middle button ‚Äî pass native\n  Send("{MButton}")\n`;
                }
                ahk += `  Return\n}\n\n`;
                return;
            }

            // normal per-key handler
            ahk += `${needsTilde}${hk}:: {\n`;

            // 3a) composite chord detection (if present for this key)
            if (entry.composite) {
                const other = entry.composite.other;
                const actionLine = entry.composite.actionLine;
                // DT0.08 gives ~80ms overlap window
                ahk += `  KeyWait("${other}", "DT0.08")\n  if (GetKeyState("${other}", "P")) {\n    ${actionLine}\n    Return\n  }\n\n`;
            }

            // 3b) Middle-held branch (layer)
            ahk += `  if (GetKeyState("MButton", "P")) {\n`;
            if (entry.mid) {
                if (entry.mid.isGest === "No") {
                    const midLine = buildActionLines(entry.mid.mainAction);
                    if (midLine) {
                        ahk += `    ${midLine}\n    Return\n`;
                    } else {
                        ahk += `    ; middle-layer defined but no action\n    Return\n`;
                    }
                } else {
                    const midBlock = buildGestureBlockForRow(entry.raw, entry.mid);
                    ahk += midBlock.split("\n").map(l => l ? "  " + l : l).join("\n") + "\n    Return\n";
                }
            } else {
                ahk += `    ; middle-layer active but no mapping for ${hk}\n    Return\n`;
            }
            ahk += `  }\n\n`;

            // 3c) Base branch
            if (entry.base) {
                const baseBlock = buildGestureBlockForRow(entry.raw, entry.base);
                ahk += baseBlock.split("\n").map(l => l ? "  " + l : l).join("\n") + "\n";
            } else {
                ahk += `  ; No base mapping: pass native\n  Send("{${entry.raw}}")\n`;
            }

            ahk += `  Return\n}\n\n`;
        });

        ahk += "#HotIf\n\n";
    });

    // Preserve config blob for import
    ahk += `; CONFIG_DATA: ${JSON.stringify(state)}`;

    const blob = new Blob([ahk], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = "mouse_v5.ahk";
    a.click();
}

function handleImport(inp) {
    const r = new FileReader();
    r.onload = () => {
        const m = r.result.match(/; CONFIG_DATA: (.*)/);
        if(m) { container.innerHTML = ""; JSON.parse(m[1]).forEach(c => addContext(c.isGlobal, c)); save(); }
    };
    r.readAsText(inp.files[0]);
}

function renderTag(n, b) {
    const s = document.createElement('div'); s.className = 'tag';
    s.innerHTML = `<span>${n}</span>`;
    const d = document.createElement('b'); d.innerHTML = ' &times;'; d.onclick = () => { s.remove(); save(); };
    s.append(d); b.append(s); save();
}

function createSelect(opts, sel) {
    const s = document.createElement('select');
    opts.forEach(o => { const op = document.createElement('option'); op.value = op.text = o; if(o === sel) op.selected = true; s.add(op); });
    return s;
}

function btn(t, f) { const b = document.createElement('button'); b.textContent = t; b.onclick = f; return b; }
function td(e) { const c = document.createElement('td'); c.append(e); return c; }
window.onload = () => {
    const s = localStorage.getItem('ahk_mouse_v5_8');
    if(s) JSON.parse(s).forEach(c => addContext(c.isGlobal, c));
};
</script>
</body>
</html>
